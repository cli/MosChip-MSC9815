\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T3,T1]{fontenc}
\usepackage[english,ngerman]{babel}
\usepackage[noenc]{tipa}
\usepackage{tipx}
\usepackage{pifont}
\usepackage{eurosym}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\usepackage{hyperref}
\hypersetup{pdftex, colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=, pdfauthor=, pdfsubject=, pdfkeywords=}
% Text styles
\newcommand\textstyleSourceText[1]{\texttt{#1}}
% Outline numbering
\setcounter{secnumdepth}{3}
\renewcommand\thesection{\arabic{section}}
% List styles
\newcommand\liststyleLi{%
\renewcommand\labelitemi{•}
\renewcommand\labelitemii{{\SmallCircle}}
\renewcommand\labelitemiii{{\FilledSmallSquare}}
\renewcommand\labelitemiv{•}
}
% Page layout (geometry)
\setlength\voffset{-1in}
\setlength\hoffset{-1in}
\setlength\topmargin{2cm}
\setlength\oddsidemargin{2cm}
\setlength\textheight{25.699cm}
\setlength\textwidth{16.999cm}
\setlength\footskip{0.0cm}
\setlength\headheight{0cm}
\setlength\headsep{0cm}
% Footnote rule
\setlength{\skip\footins}{0.119cm}
\renewcommand\footnoterule{\vspace*{-0.018cm}\setlength\leftskip{0pt}\setlength\rightskip{0pt plus 1fil}\noindent\textcolor{black}{\rule{0.25\columnwidth}{0.018cm}}\vspace*{0.101cm}}
% Pages styles
\makeatletter
\newcommand\ps@Standard{
  \renewcommand\@oddhead{}
  \renewcommand\@evenhead{}
  \renewcommand\@oddfoot{}
  \renewcommand\@evenfoot{}
  \renewcommand\thepage{\arabic{page}}
}
\bibliographystyle{plain}

\title{Hardwarenahe System- und Treiberprogrammierung}
%\subtitle{Parallelportcontroller MosChip MCS9815}
\author{\parbox{7cm}{Rolf Behrens und Christian Lins}}

\begin{document}
\sloppy

\maketitle
\tableofcontents

\section{Einleitung}

Hier sollten ein paar einleitende Worte stehen...

Bla bla

\section{Parallelportschnittstelle}

\section{Parport-Treiber in Linux}

Da die Parallelportschnittstelle aus der Steinzeit der PC-Entwicklung stammt, ist die Unterstützung
dafür im Linux-Kernel sehr gut. 
Das \verb|parport| Subsystem besteht im Wesentlichen aus zwei Teilbereichen, einem abstrakteren Highlevel-System, das
die IEEE 1284 Kommunikation beherrscht und einem Lowlevel-System, was den Hardwarezugriff auf die einzelnen Ports
kontrolliert. Auf einem PC stellt das Modul \verb|parport_pc| den architekturspezifischen Teil bereit, das Modul parport 
den generischen Teil (vgl. \cite{net:1}).

Der hardwarespezifische Treiber registriert einen \emph{Port}\footnote{Port ist hier die logische Parallelschnittstelle, nicht zu verwechseln
mit dem I/O-Port (z.B. 0x378), der im PC für den Zugriff auf die Parallelporthardware verwendet werden kann} 
im \verb|parport| Subsystem. 
Dieses benachrichtigt alle registrierten High-Level-Treiber (z.B. \verb|lp| für Drucker) über den neuen Port. Der Lowlevel-Treiber stellt
Funktionen für den Zugriff auf Basisfunktionen des Ports bereit (vgl. \cite{net:1}).

Aufgabe dieser Hausarbeit ist es, einen Lowlevel-Treiber für einen speziellen Parallelport-Controller zu schreiben. Diese 
Funktionalität ist normalerweise im architekturspezifischen Modul \verb|parport_pc| integriert.

\subsection{Strukturen}

Die Dokumentation der Strukturen wurde den Quellen des Linux-Kernels entnommen 
(vgl. \cite{net:2}, Documentation/parport-lowlevel.txt).

\subsubsection{parport\_driver}

Die Struktur \verb|parport_driver| repräsentiert einen Highlevel-Parport-Treiber.

\begin{verbatim}
struct parport_driver {
    const char *name;
    void (*attach) (struct parport *);
    void (*detach) (struct parport *);
    struct parport_driver *next;
};\end{verbatim}

Die Funktionzeiger \verb|attach| und \verb|detach| muss der Treiber zur Verfügung stellen, wenn er benachrichtigt
werden will, sobald ein neuer Parallelport im System auftaucht oder einer entfernt wird (wenn z.B. der
passende Lowlevel-Treiber entfernt wird).

\subsubsection{parport}

Die Struktur \verb|parport| repräsentiert eine logische Parallelschnittstelle.

\begin{verbatim}
struct parport {
    struct parport *next; /* next parport in list */
    const char *name;     /* port's name */
    unsigned int modes;   /* bitfield of hardware modes */
    struct parport_device_info probe_info;
                          /* IEEE1284 info */
    int number;           /* parport index */
    struct parport_operations *ops;
};\end{verbatim}

Dem Bitfeld modes kann man entnehmen, welche Modi der Schnittstelle unterstützt werden (SPP, EPP).

\subsubsection{parport\_device\_info}

\begin{verbatim}
struct parport_device_info {
    parport_device_class class;
    const char *class_name;
    const char *mfr;
    const char *model;
    const char *cmdset;
    const char *description;
};\end{verbatim} 

\subsubsection{parport\_operations}

Wie auch die Struktur \verb|file_operations| bei einem Dateisystemtreiber enthält die 
Struktur \verb|parport_operations| u.a. Funktionszeiger auf die vom Treiber unterstützten
Parallelportfunktionen.

\begin{verbatim}
struct parport_operations {
    /* IBM PC-style virtual registers. */
    void (*write_data)(struct parport *, unsigned char);
    unsigned char (*read_data)(struct parport *);

    void (*write_control)(struct parport *, unsigned char);
    unsigned char (*read_control)(struct parport *);
    unsigned char (*frob_control)(struct parport *, unsigned char mask, unsigned char val);

    unsigned char (*read_status)(struct parport *);

    /* IRQs. */
    void (*enable_irq)(struct parport *);
    void (*disable_irq)(struct parport *);

    /* Data direction. */
    void (*data_forward) (struct parport *);
    void (*data_reverse) (struct parport *);

    /* For core parport code. */
    void (*init_state)(struct pardevice *, struct parport_state *);
    void (*save_state)(struct parport *, struct parport_state *);
    void (*restore_state)(struct parport *, struct parport_state *);

    /* Block read/write */
    size_t (*epp_write_data) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*epp_read_data) (struct parport *port, void *buf, size_t len, int flags);
    size_t (*epp_write_addr) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*epp_read_addr) (struct parport *port, void *buf, size_t len, int flags);

    size_t (*ecp_write_data) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*ecp_read_data) (struct parport *port, void *buf, size_t len, int flags);
    size_t (*ecp_write_addr) (struct parport *port, const void *buf, size_t len, int flags);

    size_t (*compat_write_data) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*nibble_read_data) (struct parport *port, void *buf, size_t len, int flags);
    size_t (*byte_read_data) (struct parport *port, void *buf, size_t len, int flags);
    struct module *owner;
};\end{verbatim} 

Die einzelnen Funktionen werden in den folgenden Abschnitten erläutert.

\subsection{Funktionen}

Die Dokumentation der Funktionen wurde den Quellen des Linux-Kernels entnommen 
(vgl. \cite{net:2}, Documentation/parport-lowlevel.txt).

\subsubsection{SPP Port Funktionen}

\paragraph{write\_data}

\paragraph{read\_data}

\paragraph{read\_status}

\paragraph{read\_control}

\paragraph{write\_control}

\paragraph{frob\_control}

\paragraph{enable\_irq}

\paragraph{disable\_irq}

\paragraph{data\_forward}

\paragraph{data\_reverse}

\subsubsection{EPP Port Funktionen}

\paragraph{epp\_write\_data}

\paragraph{epp\_read\_data}

\paragraph{epp\_write\_addr}

\paragraph{epp\_read\_addr}

\subsubsection{ECP und andere Portfunktionen}

\paragraph{ecp\_write\_data}

\paragraph{ecp\_read\_data}

\paragraph{ecp\_write\_addr}

\paragraph{nibble\_read\_data}

\paragraph{byte\_read\_data}

\paragraph{compat\_write\_data}

\subsection{Globale Funktionen den parport Subsystems}

Die globalen Funktionen des parport Subsystems können sowohl von den Lowlevel- als auch
Highlevel-Treibern verwendet werden.

\paragraph{parport\_register\_driver}

\begin{verbatim}
int parport_register_driver (struct parport_driver *driver);
\end{verbatim}

Damit ein Treiber über neue Parallelschnittstellen des Systems informiert wird, muss er
sich mit dieser Methode im Kernel registrieren. Nach der Registrierung wird der Treiber
sofort über alle bereits detektierten Parallelschnittstellen informiert (attach Funktion)
und über jede, die in Zukunft von einem Lowlevel-Treiber bereitgestellt oder entfernt wird.

\paragraph{parport\_unregister\_driver}

\begin{verbatim}
void parport_unregister_driver (struct parport_driver *driver);
\end{verbatim}

Nach Aufruf dieser Funktion wird der angegebene Treiber nicht mehr über die Registrierung
und Deregistrierung von Parports informiert. Die bereits registrierten Geräte werden \emph{nicht}
automatisch deregistriert.

% \paragraph{parport\_enumerate}
% Lassen wir weg, da die Funktion deprecated ist.

\paragraph{parport\_register\_device}

\begin{verbatim}
typedef int (*preempt_func) (void *handle);
typedef void (*wakeup_func) (void *handle);
typedef int (*irq_func) (int irq, void *handle, struct pt_regs *);

struct pardevice *parport_register_device(struct parport *port,
                                          const char *name,
                                          preempt_func preempt,
                                          wakeup_func wakeup,
                                          irq_func irq,
                                          int flags,
                                          void *handle);
\end{verbatim}

Diese Funktion wird verwendet um einen Gerätetreiber, der den angegebenen Parallelport verwenden will,
im parport System zu registrieren. Der gewählte Gerätename ('name') muss während der Lebenszeit des
Geräts eindeutig sein. 
Die über preempt spezifizierte Funktion wird aufgerufen, wenn ein anderer Treiber den Port verwenden
möchte (es können mehrere Geräte eine Parallelschnittstelle verwenden).
Die wakeup Funktion wird aufgerufen, sobald der Parallelport von einem anderen Treiber wieder
freigegeben wurde. Die Funktion irq wird aufgerufen, wenn am angegebenen Parallelport ein Interrupt
auftritt.

\paragraph{parport\_unregister\_device}

\begin{verbatim}
void parport_unregister_device (struct pardevice *dev)
\end{verbatim}

Deregistriert das angegebene Gerät ('dev').

\paragraph{parport\_claim und parport\_claim\_or\_block}

\begin{verbatim}
int parport_claim (struct pardevice *dev)
int parport_claim_or_block (struct pardevice *dev)
\end{verbatim}

\paragraph{parport\_release}

\begin{verbatim}
void parport_release (struct pardevice *dev)
\end{verbatim}

\paragraph{parport\_yield und parport\_yield\_blocking}

\begin{verbatim}
int parport_yield (struct pardevice *dev)
int parport_yield_blocking (struct pardevice *dev);
\end{verbatim}

\paragraph{parport\_wait\_peripheral}
\begin{verbatim}
int parport_wait_peripheral (struct parport *port,
			     unsigned char mask,
			     unsigned char val);
\end{verbatim}


\paragraph{parport\_poll\_peripheral}

\begin{verbatim}
int parport_poll_peripheral (struct parport *port,
			     unsigned char mask,
			     unsigned char val,
			     int usec);
\end{verbatim}


\paragraph{parport\_wait\_event}
\begin{verbatim}
int parport_wait_event (struct parport *port, signed long timeout)
\end{verbatim}


\paragraph{parport\_negotiate}

\paragraph{parport\_read}

\paragraph{parport\_write}

\paragraph{parport\_open}

\paragraph{parport\_close}

\paragraph{parport\_device\_id}

\paragraph{parport\_device\_coords}

\paragraph{parport\_find\_class}

\paragraph{parport\_find\_device}

\paragraph{parport\_set\_timeout}

\section{Der MosChip MCS9815 Controller}

\bibliography{literatur}

\end{document}