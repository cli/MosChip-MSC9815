\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T3,T1]{fontenc}
\usepackage[english,ngerman]{babel}
\usepackage[noenc]{tipa}
\usepackage{tipx}
\usepackage{pifont}
\usepackage{eurosym}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\usepackage{hyperref}
\hypersetup{pdftex, colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=, pdfauthor=, pdfsubject=, pdfkeywords=}
% Text styles
\newcommand\textstyleSourceText[1]{\texttt{#1}}
% Outline numbering
\setcounter{secnumdepth}{3}
\renewcommand\thesection{\arabic{section}}
% List styles
\newcommand\liststyleLi{%
\renewcommand\labelitemi{•}
\renewcommand\labelitemii{{\SmallCircle}}
\renewcommand\labelitemiii{{\FilledSmallSquare}}
\renewcommand\labelitemiv{•}
}
% Page layout (geometry)
\setlength\voffset{-1in}
\setlength\hoffset{-1in}
\setlength\topmargin{2cm}
\setlength\oddsidemargin{2cm}
\setlength\textheight{25.699cm}
\setlength\textwidth{16.999cm}
\setlength\footskip{0.0cm}
\setlength\headheight{0cm}
\setlength\headsep{0cm}
% Footnote rule
\setlength{\skip\footins}{0.119cm}
\renewcommand\footnoterule{\vspace*{-0.018cm}\setlength\leftskip{0pt}\setlength\rightskip{0pt plus 1fil}\noindent\textcolor{black}{\rule{0.25\columnwidth}{0.018cm}}\vspace*{0.101cm}}
% Pages styles
\makeatletter
\newcommand\ps@Standard{
  \renewcommand\@oddhead{}
  \renewcommand\@evenhead{}
  \renewcommand\@oddfoot{}
  \renewcommand\@evenfoot{}
  \renewcommand\thepage{\arabic{page}}
}
\bibliographystyle{plain}

\title{Hardwarenahe System- und Treiberprogrammierung}
%\subtitle{Parallelportcontroller MosChip MCS9815}
\author{\parbox{7cm}{Rolf Behrens und Christian Lins}}

\begin{document}
\sloppy

\maketitle
\tableofcontents

\section{Einleitung}

Hier sollten ein paar einleitende Worte stehen...

Bla bla

\section{Parallelportschnittstelle}

\section{Parport-Treiber in Linux}

Da die Parallelportschnittstelle aus der Steinzeit der PC-Entwicklung stammt, ist die Unterstützung
dafür im Linux-Kernel sehr gut. 
Das \verb|parport| Subsystem besteht im Wesentlichen aus zwei Teilbereichen, einem abstrakteren Highlevel-System, das
die IEEE 1284 Kommunikation beherrscht und einem Lowlevel-System, was den Hardwarezugriff auf die einzelnen Ports
kontrolliert. Auf einem PC stellt das Modul \verb|parport_pc| den architekturspezifischen Teil bereit, das Modul parport 
den generischen Teil.

Der hardwarespezifische Treiber registriert einen \emph{Port}\footnote{Port ist hier die logische Parallelschnittstelle, nicht zu verwechseln
mit dem I/O-Port (z.B. 0x378), der im PC für den Zugriff auf die Parallelporthardware verwendet werden kann} 
im \verb|parport| Subsystem. 
Dieses benachrichtigt alle registrierten High-Level-Treiber (z.B. \verb|lp| für Drucker) über den neuen Port. Der Lowlevel-Treiber stellt
Funktionen für den Zugriff auf Basisfunktionen des Ports bereit.

Aufgabe dieser Hausarbeit ist es, einen Lowlevel-Treiber für einen speziellen Parallelport-Controller zu schreiben. Diese 
Funktionalität ist normalerweise im architekturspezifischen Modul \verb|parport_pc| integriert.

\subsection{Strukturen}

\subsubsection{parport\_driver}

Die Struktur \verb|parport_driver| repräsentiert einen Highlevel-Parport-Treiber.

\begin{verbatim}
struct parport_driver {
    const char *name;
    void (*attach) (struct parport *);
    void (*detach) (struct parport *);
    struct parport_driver *next;
};\end{verbatim}

Die Funktionzeiger \verb|attach| und \verb|detach| muss der Treiber zur Verfügung stellen, wenn er benachrichtigt
werden will, sobald ein neuer Parallelport im System auftaucht oder einer entfernt wird (wenn z.B. der
passende Lowlevel-Treiber entfernt wird).

\subsubsection{parport}

Die Struktur \verb|parport| repräsentiert eine logische Parallelschnittstelle.

\begin{verbatim}
struct parport {
    struct parport *next; /* next parport in list */
    const char *name;     /* port's name */
    unsigned int modes;   /* bitfield of hardware modes */
    struct parport_device_info probe_info;
                          /* IEEE1284 info */
    int number;           /* parport index */
    struct parport_operations *ops;
};\end{verbatim}

Dem Bitfeld modes kann man entnehmen, welche Modi der Schnittstelle unterstützt werden (SPP, EPP).

\subsubsection{parport\_device\_info}

\begin{verbatim}
struct parport_device_info {
    parport_device_class class;
    const char *class_name;
    const char *mfr;
    const char *model;
    const char *cmdset;
    const char *description;
};\end{verbatim} 

\subsubsection{parport\_operations}

\begin{verbatim}
struct parport_operations {
    /* IBM PC-style virtual registers. */
    void (*write_data)(struct parport *, unsigned char);
    unsigned char (*read_data)(struct parport *);

    void (*write_control)(struct parport *, unsigned char);
    unsigned char (*read_control)(struct parport *);
    unsigned char (*frob_control)(struct parport *, unsigned char mask, unsigned char val);

    unsigned char (*read_status)(struct parport *);

    /* IRQs. */
    void (*enable_irq)(struct parport *);
    void (*disable_irq)(struct parport *);

    /* Data direction. */
    void (*data_forward) (struct parport *);
    void (*data_reverse) (struct parport *);

    /* For core parport code. */
    void (*init_state)(struct pardevice *, struct parport_state *);
    void (*save_state)(struct parport *, struct parport_state *);
    void (*restore_state)(struct parport *, struct parport_state *);

    /* Block read/write */
    size_t (*epp_write_data) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*epp_read_data) (struct parport *port, void *buf, size_t len, int flags);
    size_t (*epp_write_addr) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*epp_read_addr) (struct parport *port, void *buf, size_t len, int flags);

    size_t (*ecp_write_data) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*ecp_read_data) (struct parport *port, void *buf, size_t len, int flags);
    size_t (*ecp_write_addr) (struct parport *port, const void *buf, size_t len, int flags);

    size_t (*compat_write_data) (struct parport *port, const void *buf, size_t len, int flags);
    size_t (*nibble_read_data) (struct parport *port, void *buf, size_t len, int flags);
    size_t (*byte_read_data) (struct parport *port, void *buf, size_t len, int flags);
    struct module *owner;
};\end{verbatim} 

\subsection{SPP Port Funktionen}

\subsection{EPP Port Funktionen}

\subsection{ECP und andere Portfunktionen}

\subsection{Globale Funktionen den parport Subsystems}

\section{Der MosChip MCS9815 Controller}

\bibliography{literatur}

\end{document}